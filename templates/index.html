<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>局域网文件传输</title>
  <style>
    :root {
      --bg1: #f3f8ff;
      --bg2: #edf8f1;
      --panel: #ffffff;
      --line: #d7e0ea;
      --txt: #1d2b36;
      --muted: #607080;
      --mobile: #e8f7ff;
      --desktop: #eef8ea;
      --accent: #166534;
      --danger: #be123c;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Segoe UI", "PingFang SC", "Microsoft YaHei", sans-serif;
      color: var(--txt);
      background: radial-gradient(circle at 0% 0%, var(--bg1), transparent 55%),
                  radial-gradient(circle at 100% 100%, var(--bg2), transparent 50%),
                  #f7fafc;
      display: flex;
      justify-content: center;
      padding: 16px;
    }

    .app {
      width: min(720px, 100%);
      height: calc(100vh - 32px);
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 18px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      box-shadow: 0 12px 30px rgba(20, 35, 50, 0.08);
    }

    .top {
      padding: 12px 14px;
      border-bottom: 1px solid var(--line);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      background: #fbfdff;
    }

    .title {
      font-weight: 600;
      font-size: 15px;
    }

    .meta {
      color: var(--muted);
      font-size: 12px;
    }

    .status {
      font-size: 12px;
      color: var(--muted);
      white-space: nowrap;
    }

    .status.ok { color: #0f766e; }
    .status.err { color: var(--danger); }

    .top-actions {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .qr-card {
      margin: 12px 14px 0;
      border: 1px solid var(--line);
      border-radius: 12px;
      background: #f8fbff;
      padding: 12px;
      display: none;
      align-items: center;
      gap: 12px;
    }

    .qr-card.show { display: flex; }

    .qr-img {
      width: 96px;
      height: 96px;
      border: 1px solid #c8d6e5;
      border-radius: 8px;
      background: #fff;
      object-fit: contain;
      padding: 4px;
    }

    .qr-text {
      flex: 1;
      min-width: 0;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .qr-meta {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .qr-title {
      font-size: 13px;
      font-weight: 600;
      color: #22384a;
    }

    .qr-link {
      font-size: 12px;
      color: #1d4ed8;
      text-decoration: none;
      word-break: break-all;
    }

    .qr-link:hover { text-decoration: underline; }

    .qr-expire {
      font-size: 12px;
      color: #465a6f;
    }

    .btn.qr-refresh {
      padding: 4px 8px;
      font-size: 12px;
    }

    .records {
      flex: 1;
      overflow-y: auto;
      padding: 14px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .empty {
      margin: auto;
      color: var(--muted);
      font-size: 13px;
    }

    .row {
      display: flex;
    }

    .row.mobile { justify-content: flex-end; }
    .row.desktop { justify-content: flex-start; }

    .bubble {
      max-width: 90%;
      border-radius: 12px;
      padding: 10px 12px;
      border: 1px solid var(--line);
      background: var(--mobile);
    }

    .row.desktop .bubble { background: var(--desktop); }

    .name {
      font-size: 14px;
      font-weight: 600;
      word-break: break-all;
    }

    .desc {
      margin-top: 4px;
      color: var(--muted);
      font-size: 12px;
    }

    .actions {
      margin-top: 8px;
      display: flex;
      gap: 8px;
    }

    .btn {
      border: 1px solid #b9c5d2;
      background: #fff;
      color: #243646;
      border-radius: 8px;
      font-size: 12px;
      padding: 6px 10px;
      cursor: pointer;
    }

    .btn.primary {
      border-color: #1d4ed8;
      color: #fff;
      background: #1d4ed8;
    }

    .btn.send {
      border-color: var(--accent);
      background: var(--accent);
      color: #fff;
      min-width: 130px;
      height: 40px;
      border-radius: 999px;
      font-size: 14px;
      font-weight: 600;
    }

    .bottom {
      border-top: 1px solid var(--line);
      padding: 10px 14px;
      display: flex;
      gap: 10px;
      align-items: center;
      background: #fbfdff;
    }

    .tip {
      color: var(--muted);
      font-size: 12px;
      line-height: 1.4;
      flex: 1;
    }

    #fileInput { display: none; }

    .drop-zone {
      margin: 0 14px 10px;
      border: 1px dashed #9ab4cc;
      color: #46657f;
      border-radius: 12px;
      padding: 10px;
      text-align: center;
      font-size: 12px;
      background: #f5f9ff;
      display: none;
    }

    .drop-zone.active {
      display: block;
      animation: pulse 1s ease-in-out infinite alternate;
    }

    .upload-jobs {
      margin: 0 14px 10px;
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 8px 10px;
      background: #f8fbff;
      display: none;
      flex-direction: column;
      gap: 8px;
      max-height: 180px;
      overflow-y: auto;
    }

    .upload-jobs.show { display: flex; }

    .upload-job {
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 4px;
      padding-right: 24px;
    }

    .upload-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      font-size: 12px;
    }

    .upload-name {
      font-weight: 600;
      color: #22384a;
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .upload-status {
      color: #506578;
      white-space: nowrap;
    }

    .upload-meta {
      font-size: 12px;
      color: #597087;
    }

    .progress-track {
      height: 8px;
      border-radius: 999px;
      overflow: hidden;
      background: #d4e1ee;
    }

    .progress-fill {
      height: 100%;
      width: 0;
      border-radius: 999px;
      background: linear-gradient(90deg, #22c55e, #16a34a);
      transition: width 0.16s linear;
    }

    .upload-job.done .upload-status { color: #15803d; }
    .upload-job.fail .upload-status { color: var(--danger); }
    .upload-job.fail .progress-fill { background: var(--danger); }
    .upload-job.canceled .upload-status { color: var(--danger); }
    .upload-job.canceled .progress-fill { background: #ef4444; }

    .job-cancel-btn {
      position: absolute;
      top: 0;
      right: 0;
      width: 16px;
      height: 16px;
      border: 1px solid #ef4444;
      border-radius: 999px;
      background: #fff;
      color: #dc2626;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      font-size: 11px;
      font-weight: 700;
      cursor: pointer;
    }

    .job-cancel-btn:hover {
      background: #fee2e2;
    }

    .toast {
      position: fixed;
      left: 50%;
      bottom: 28px;
      transform: translateX(-50%);
      background: rgba(10, 20, 30, 0.88);
      color: #fff;
      border-radius: 999px;
      padding: 8px 14px;
      font-size: 12px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
      z-index: 99;
    }

    .toast.show { opacity: 1; }

    .settings {
      margin: 10px 14px 0;
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px;
      background: #fbfdff;
      display: none;
      gap: 8px;
    }

    .settings.show { display: grid; }

    .setting-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      font-size: 12px;
      color: #33485a;
    }

    .setting-input {
      border: 1px solid #b9c5d2;
      border-radius: 8px;
      padding: 6px 8px;
      font-size: 12px;
      min-width: 120px;
    }

    .setting-note {
      color: var(--muted);
      font-size: 12px;
    }

    @keyframes pulse {
      from { box-shadow: 0 0 0 rgba(29, 78, 216, 0.0); }
      to { box-shadow: 0 0 0 4px rgba(29, 78, 216, 0.1); }
    }

  </style>
</head>
<body>
  <div class="app">
    <div class="top">
      <div>
        <div class="title">局域网文件传输</div>
        <div class="meta" id="meta"></div>
      </div>
      <div class="top-actions">
        <button class="btn" id="settingsBtn" type="button">设置</button>
        <div class="status" id="status">连接中...</div>
      </div>
    </div>

    <div class="qr-card" id="qrCard">
      <img class="qr-img" id="qrImage" alt="手机扫码二维码" />
      <div class="qr-text">
        <div class="qr-title">手机扫码打开上传页</div>
        <a class="qr-link" id="qrLink" target="_blank" rel="noopener noreferrer"></a>
        <div class="qr-meta">
          <span class="qr-expire" id="qrExpire">有效期剩余 --</span>
          <button class="btn qr-refresh" id="refreshQrBtn" type="button">刷新二维码</button>
        </div>
      </div>
    </div>

    <div class="records" id="records">
      <div class="empty" id="empty">暂无传输记录</div>
    </div>

    <div class="drop-zone" id="dropZone">拖拽文件到此区域，立即发送到手机</div>

    <div class="upload-jobs" id="uploadJobs"></div>

    <div class="settings" id="settingsPanel">
      <div class="setting-row" id="limitRow">
        <span>上传限制</span>
        <input class="setting-input" id="uploadLimitGb" type="number" min="1" max="100" step="1" />
        <span>GB</span>
        <button class="btn" id="saveLimitBtn" type="button">保存限制</button>
      </div>
      <div class="setting-row" id="downloadDirRow">
        <span>下载目录</span>
        <input class="setting-input" id="downloadDirInput" type="text" placeholder="例如 C:\Users\YourName\Downloads" style="min-width: 320px;" />
        <button class="btn" id="pickDownloadDirBtn" type="button">选择文件夹</button>
        <button class="btn" id="saveDownloadDirBtn" type="button">保存路径</button>
        <button class="btn" id="openDownloadDirBtn" type="button">打开目录</button>
        <button class="btn" id="resetDownloadDirBtn" type="button">恢复默认</button>
      </div>
      <div class="setting-note" id="secureNote">默认下载目录为 Windows Downloads，上传上限默认 10GB，可按需调整。</div>
    </div>

    <div class="bottom">
      <div class="tip" id="tip"></div>
      <button class="btn send" id="sendBtn">发送文件</button>
      <input id="fileInput" type="file" multiple />
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <script id="serverConfigData" type="application/json">
    {{ {
      "mobileUrl": mobile_url,
      "mobileQrDataUrl": mobile_qr_data_url,
      "tokenExpiresAt": token_expires_at,
      "sessionId": session_id,
      "accessDenied": access_denied,
      "accessDeniedReason": access_denied_reason
    } | tojson }}
  </script>

  <script>
    const serverConfig = (() => {
      const defaults = {
        mobileUrl: '',
        mobileQrDataUrl: '',
        tokenExpiresAt: 0,
        sessionId: '',
        accessDenied: false,
        accessDeniedReason: '',
      };
      const el = document.getElementById('serverConfigData');
      if (!el) return defaults;
      try {
        const parsed = JSON.parse(el.textContent || '{}');
        return { ...defaults, ...parsed };
      } catch (_) {
        return defaults;
      }
    })();

    const state = {
      role: detectRole(),
      ws: null,
      hbTimer: null,
      reconnectTimer: null,
      records: [],
      recordIdSet: new Set(),
      sessionId: serverConfig.sessionId || '',
      qrExpiresAt: Number(serverConfig.tokenExpiresAt || 0),
      qrRefreshInFlight: false,
      qrCountdownTimer: null,
      maxUploadBytes: 10 * 1024 * 1024 * 1024,
      downloadDir: '',
      defaultDownloadDir: '',
      uploadJobs: [],
      uploadJobCounter: 0,
    };

    const ui = {
      records: document.getElementById('records'),
      empty: document.getElementById('empty'),
      sendBtn: document.getElementById('sendBtn'),
      fileInput: document.getElementById('fileInput'),
      status: document.getElementById('status'),
      meta: document.getElementById('meta'),
      tip: document.getElementById('tip'),
      dropZone: document.getElementById('dropZone'),
      uploadJobs: document.getElementById('uploadJobs'),
      toast: document.getElementById('toast'),
      qrCard: document.getElementById('qrCard'),
      qrImage: document.getElementById('qrImage'),
      qrLink: document.getElementById('qrLink'),
      qrExpire: document.getElementById('qrExpire'),
      refreshQrBtn: document.getElementById('refreshQrBtn'),
      settingsBtn: document.getElementById('settingsBtn'),
      settingsPanel: document.getElementById('settingsPanel'),
      limitRow: document.getElementById('limitRow'),
      uploadLimitGb: document.getElementById('uploadLimitGb'),
      saveLimitBtn: document.getElementById('saveLimitBtn'),
      downloadDirRow: document.getElementById('downloadDirRow'),
      downloadDirInput: document.getElementById('downloadDirInput'),
      pickDownloadDirBtn: document.getElementById('pickDownloadDirBtn'),
      saveDownloadDirBtn: document.getElementById('saveDownloadDirBtn'),
      openDownloadDirBtn: document.getElementById('openDownloadDirBtn'),
      resetDownloadDirBtn: document.getElementById('resetDownloadDirBtn'),
      secureNote: document.getElementById('secureNote'),
    };

    function detectRole() {
      const role = new URLSearchParams(location.search).get('role');
      if (role === 'desktop' || role === 'mobile') return role;
      return /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent) ? 'mobile' : 'desktop';
    }

    function fmtSize(bytes) {
      if (bytes < 1024) return `${bytes} B`;
      if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
      if (bytes < 1024 * 1024 * 1024) return `${(bytes / 1024 / 1024).toFixed(1)} MB`;
      return `${(bytes / 1024 / 1024 / 1024).toFixed(2)} GB`;
    }

    function showToast(text) {
      ui.toast.textContent = text;
      ui.toast.classList.add('show');
      setTimeout(() => ui.toast.classList.remove('show'), 1800);
    }

    function setStatus(text, ok = false, err = false) {
      ui.status.textContent = text;
      ui.status.classList.toggle('ok', ok);
      ui.status.classList.toggle('err', err);
    }

    function toggleSettingsPanel(forceOpen) {
      const shouldOpen = typeof forceOpen === 'boolean' ? forceOpen : !ui.settingsPanel.classList.contains('show');
      ui.settingsPanel.classList.toggle('show', shouldOpen);
      if (ui.settingsBtn) ui.settingsBtn.textContent = shouldOpen ? '收起设置' : '设置';
    }

    function createRecordNode(record) {
      const row = document.createElement('div');
      row.className = `row ${record.source === 'desktop' ? 'desktop' : 'mobile'}`;

      const bubble = document.createElement('div');
      bubble.className = 'bubble';

      const name = document.createElement('div');
      name.className = 'name';
      name.textContent = record.name;

      const desc = document.createElement('div');
      desc.className = 'desc';
      desc.textContent = `${record.source === 'desktop' ? '电脑' : '手机'} · ${fmtSize(record.size)} · ${record.created_at}`;

      const actions = document.createElement('div');
      actions.className = 'actions';

      const dlBtn = document.createElement('button');
      dlBtn.className = 'btn';
      dlBtn.textContent = '下载';
      dlBtn.addEventListener('click', () => triggerDownload(record));

      actions.appendChild(dlBtn);
      bubble.appendChild(name);
      bubble.appendChild(desc);
      bubble.appendChild(actions);
      row.appendChild(bubble);
      return row;
    }

    function renderRecords() {
      ui.records.innerHTML = '';
      if (state.records.length === 0) {
        ui.records.appendChild(ui.empty);
        ui.empty.style.display = 'block';
        return;
      }

      ui.empty.style.display = 'none';
      for (const record of state.records) {
        ui.records.appendChild(createRecordNode(record));
      }
      ui.records.scrollTop = ui.records.scrollHeight;
    }

    function addRecord(record, notify = true) {
      if (state.recordIdSet.has(record.id)) return;
      state.recordIdSet.add(record.id);
      state.records.push(record);
      renderRecords();

      if (!notify) return;

      if (state.role === 'mobile' && record.source === 'desktop') {
        showToast(`收到文件：${record.name}`);
        notifyInBackground(record);
      }
    }

    function removeRecord(recordId) {
      if (!state.recordIdSet.has(recordId)) return;
      state.recordIdSet.delete(recordId);
      state.records = state.records.filter((item) => item.id !== recordId);
      renderRecords();
    }

    async function triggerDownload(record) {
      try {
        if (state.role === 'mobile') {
          await downloadFileInBrowserWithSpeed(record);
          showToast(`下载完成：${record.name}`);
          return;
        }

        const data = await saveFileToDesktopWithSpeed(record);
        const savedName = data.file_name || record.name;
        showToast(`已保存：${savedName}`);
      } catch (err) {
        if (isCancelError(err)) {
          showToast('已取消下载');
          return;
        }
        console.error(err);
        showToast('下载失败');
      }
    }

    function authHeaders() {
      if (!state.sessionId) return {};
      return { 'X-Session-Id': state.sessionId };
    }

    function isCancelError(err) {
      return !!(err && (err.code === 'CANCELED' || err.name === 'AbortError'));
    }

    function buildCancelError(message) {
      const error = new Error(message || '操作已取消');
      error.code = 'CANCELED';
      return error;
    }

    function isTransferActive(job) {
      return !!job && (job.status === 'uploading' || job.status === 'downloading');
    }

    function createTransferJob({ name, size, kind, cancelable = false }) {
      const id = `upload-${Date.now()}-${state.uploadJobCounter++}`;
      state.uploadJobs.push({
        id,
        name,
        size: Math.max(0, Number(size) || 0),
        kind: kind === 'download' ? 'download' : 'upload',
        loaded: 0,
        percent: 0,
        speedBps: 0,
        startedAt: Date.now(),
        lastTickAt: Date.now(),
        status: kind === 'download' ? 'downloading' : 'uploading',
        cancelable: !!cancelable,
        cancelRequested: false,
        aborter: null,
      });
      renderUploadJobs();
      return id;
    }

    function getTransferJob(jobId) {
      return state.uploadJobs.find((item) => item.id === jobId);
    }

    function updateTransferJob(jobId, patch) {
      const job = getTransferJob(jobId);
      if (!job) return;
      Object.assign(job, patch);
      if (typeof patch.loaded === 'number' && job.size > 0 && typeof patch.percent !== 'number') {
        job.percent = Math.min(100, (job.loaded / job.size) * 100);
      }
      renderUploadJobs();
    }

    function cancelTransfer(jobId) {
      const job = getTransferJob(jobId);
      if (!job || !job.cancelable || !isTransferActive(job)) return;
      job.cancelRequested = true;
      job.cancelable = false;
      const aborter = job.aborter;
      job.aborter = null;
      renderUploadJobs();
      if (typeof aborter === 'function') {
        try {
          aborter();
        } catch (_) {
        }
      }
    }

    function updateTransferProgress(jobId, loaded, total) {
      const job = getTransferJob(jobId);
      if (!job) return;
      const now = Date.now();
      const prevLoaded = Math.max(0, Number(job.loaded) || 0);
      const prevTick = Number(job.lastTickAt) || Number(job.startedAt) || now;
      const safeLoaded = Math.max(0, Number(loaded) || 0);
      const safeTotal = Math.max(0, Number(total) || 0) || job.size || safeLoaded;
      const deltaBytes = Math.max(0, safeLoaded - prevLoaded);
      const deltaMs = Math.max(1, now - prevTick);
      const instantBps = (deltaBytes * 1000) / deltaMs;
      const blendedBps = job.speedBps > 0 ? (job.speedBps * 0.72 + instantBps * 0.28) : instantBps;

      job.loaded = Math.min(safeLoaded, safeTotal);
      job.percent = safeTotal > 0 ? Math.min(100, (job.loaded / safeTotal) * 100) : 0;
      job.speedBps = Number.isFinite(blendedBps) ? Math.max(0, blendedBps) : Math.max(0, Number(job.speedBps) || 0);
      job.lastTickAt = now;
      renderUploadJobs();
    }

    function removeTransferJob(jobId) {
      const next = state.uploadJobs.filter((item) => item.id !== jobId);
      if (next.length === state.uploadJobs.length) return;
      state.uploadJobs = next;
      renderUploadJobs();
    }

    function scheduleTransferJobRemoval(jobId, delayMs) {
      setTimeout(() => removeTransferJob(jobId), delayMs);
    }

    function transferStatusLabel(job) {
      if (job.status === 'done') return job.kind === 'download' ? '下载完成' : '上传完成';
      if (job.status === 'fail') return job.kind === 'download' ? '下载失败' : '上传失败';
      if (job.status === 'canceled') return job.kind === 'download' ? '下载已取消' : '上传已取消';
      return job.kind === 'download' ? '下载中' : '上传中';
    }

    function formatPercent(percent) {
      const safe = Math.max(0, Math.min(100, Number(percent) || 0));
      return `${Math.round(safe)}%`;
    }

    function fmtSpeed(bytesPerSecond) {
      const speed = Number(bytesPerSecond);
      if (!Number.isFinite(speed) || speed <= 0) return '--';
      return `${fmtSize(speed)}/s`;
    }

    function averageSpeedBps(startedAt, bytes) {
      const started = Number(startedAt) || Date.now();
      const totalBytes = Math.max(0, Number(bytes) || 0);
      const elapsedMs = Math.max(1, Date.now() - started);
      return totalBytes > 0 ? (totalBytes * 1000) / elapsedMs : 0;
    }

    async function saveFileToDesktopWithSpeed(record) {
      const totalBytes = Math.max(0, Number(record.size) || 0);
      const jobId = createTransferJob({
        name: record.name,
        size: totalBytes,
        kind: 'download',
      });
      const startedAt = Date.now();
      try {
        const resp = await fetch(`/files/${encodeURIComponent(record.id)}/save`, {
          method: 'POST',
          headers: authHeaders(),
        });
        const data = await resp.json().catch(() => ({}));
        if (!resp.ok) throw new Error(data.error || `保存失败(${resp.status})`);

        updateTransferJob(jobId, {
          loaded: totalBytes,
          percent: 100,
          speedBps: averageSpeedBps(startedAt, totalBytes),
          status: 'done',
          lastTickAt: Date.now(),
        });
        scheduleTransferJobRemoval(jobId, 3500);
        return data;
      } catch (err) {
        updateTransferJob(jobId, { status: 'fail' });
        scheduleTransferJobRemoval(jobId, 7000);
        throw err;
      }
    }

    function downloadFileInBrowserWithSpeed(record) {
      const totalBytes = Math.max(0, Number(record.size) || 0);
      const jobId = createTransferJob({
        name: record.name,
        size: totalBytes,
        kind: 'download',
        cancelable: true,
      });
      const startedAt = Date.now();

      return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', `/files/${encodeURIComponent(record.id)}`, true);
        xhr.responseType = 'blob';
        const headers = authHeaders();
        for (const [key, value] of Object.entries(headers)) {
          xhr.setRequestHeader(key, value);
        }
        updateTransferJob(jobId, { aborter: () => xhr.abort() });

        xhr.onprogress = (event) => {
          const progressTotal = event.lengthComputable && event.total > 0 ? event.total : totalBytes;
          updateTransferProgress(jobId, event.loaded, progressTotal);
        };

        xhr.onerror = () => {
          updateTransferJob(jobId, { status: 'fail', cancelable: false, aborter: null });
          scheduleTransferJobRemoval(jobId, 7000);
          reject(new Error('网络错误'));
        };

        xhr.onabort = () => {
          const job = getTransferJob(jobId);
          const canceled = !!(job && job.cancelRequested);
          if (canceled) {
            updateTransferJob(jobId, { status: 'canceled', speedBps: 0, cancelable: false, aborter: null });
            scheduleTransferJobRemoval(jobId, 4500);
            reject(buildCancelError('下载已取消'));
            return;
          }
          updateTransferJob(jobId, { status: 'fail', cancelable: false, aborter: null });
          scheduleTransferJobRemoval(jobId, 7000);
          reject(new Error('下载中断'));
        };

        xhr.onload = () => {
          if (xhr.status < 200 || xhr.status >= 300) {
            updateTransferJob(jobId, { status: 'fail', cancelable: false, aborter: null });
            scheduleTransferJobRemoval(jobId, 7000);
            reject(new Error(`下载失败(${xhr.status})`));
            return;
          }

          const blob = xhr.response instanceof Blob ? xhr.response : new Blob([xhr.response || '']);
          const loadedBytes = totalBytes > 0 ? totalBytes : (blob.size || 0);
          const currentJob = getTransferJob(jobId);
          const smoothSpeed = currentJob ? Number(currentJob.speedBps) || 0 : 0;
          updateTransferJob(jobId, {
            loaded: loadedBytes,
            percent: 100,
            speedBps: Math.max(smoothSpeed, averageSpeedBps(startedAt, loadedBytes)),
            status: 'done',
            cancelable: false,
            aborter: null,
            lastTickAt: Date.now(),
          });
          scheduleTransferJobRemoval(jobId, 3500);

          const blobUrl = URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = blobUrl;
          link.download = record.name || 'downloaded_file';
          link.style.display = 'none';
          document.body.appendChild(link);
          link.click();
          link.remove();
          setTimeout(() => URL.revokeObjectURL(blobUrl), 3000);
          resolve();
        };

        xhr.send();
      });
    }

    function renderUploadJobs() {
      ui.uploadJobs.innerHTML = '';
      if (!state.uploadJobs.length) {
        ui.uploadJobs.classList.remove('show');
        return;
      }
      ui.uploadJobs.classList.add('show');

      for (const job of state.uploadJobs) {
        const node = document.createElement('div');
        node.className = `upload-job ${job.status === 'done' ? 'done' : ''} ${job.status === 'fail' ? 'fail' : ''} ${job.status === 'canceled' ? 'canceled' : ''}`.trim();

        const head = document.createElement('div');
        head.className = 'upload-head';

        const name = document.createElement('span');
        name.className = 'upload-name';
        name.textContent = job.name;

        const status = document.createElement('span');
        status.className = 'upload-status';
        status.textContent = transferStatusLabel(job);

        head.appendChild(name);
        head.appendChild(status);
        if (job.kind === 'download' && job.cancelable && isTransferActive(job)) {
          const cancelBtn = document.createElement('button');
          cancelBtn.type = 'button';
          cancelBtn.className = 'job-cancel-btn';
          cancelBtn.textContent = '×';
          cancelBtn.setAttribute('aria-label', '取消');
          cancelBtn.addEventListener('click', () => cancelTransfer(job.id));
          node.appendChild(cancelBtn);
        }

        const meta = document.createElement('div');
        meta.className = 'upload-meta';
        const actionText = job.kind === 'download' ? '下载' : '上传';
        const speedText = job.status === 'done'
          ? `平均${actionText}速度 ${fmtSpeed(job.speedBps)}`
          : `${actionText}速度 ${fmtSpeed(job.speedBps)}`;
        meta.textContent = `${fmtSize(job.loaded)} / ${fmtSize(job.size)} · ${formatPercent(job.percent)} · ${speedText}`;

        const track = document.createElement('div');
        track.className = 'progress-track';

        const fill = document.createElement('div');
        fill.className = 'progress-fill';
        const isActive = job.status === 'uploading' || job.status === 'downloading';
        const shownPercent = isActive ? Math.max(2, job.percent) : job.percent;
        fill.style.width = `${Math.max(0, Math.min(100, shownPercent))}%`;

        track.appendChild(fill);
        node.appendChild(head);
        node.appendChild(meta);
        node.appendChild(track);
        ui.uploadJobs.appendChild(node);
      }
    }

    function sendFileWithProgress(file, source = state.role) {
      const totalBytes = Math.max(0, Number(file.size) || 0);
      const jobId = createTransferJob({
        name: file.name,
        size: totalBytes,
        kind: 'upload',
        cancelable: true,
      });

      return new Promise((resolve, reject) => {
        const form = new FormData();
        form.append('file', file, file.name);
        form.append('source', source);

        const xhr = new XMLHttpRequest();
        xhr.open('POST', '/upload', true);
        const headers = authHeaders();
        for (const [key, value] of Object.entries(headers)) {
          xhr.setRequestHeader(key, value);
        }
        updateTransferJob(jobId, { aborter: () => xhr.abort() });

        xhr.upload.onprogress = (event) => {
          const progressTotal = event.lengthComputable && event.total > 0 ? event.total : totalBytes;
          updateTransferProgress(jobId, event.loaded, progressTotal);
        };

        xhr.onerror = () => {
          updateTransferJob(jobId, { status: 'fail', cancelable: false, aborter: null });
          scheduleTransferJobRemoval(jobId, 6000);
          reject(new Error('网络错误'));
        };

        xhr.onabort = () => {
          const job = getTransferJob(jobId);
          const canceled = !!(job && job.cancelRequested);
          if (canceled) {
            updateTransferJob(jobId, { status: 'canceled', speedBps: 0, cancelable: false, aborter: null });
            scheduleTransferJobRemoval(jobId, 4500);
            reject(buildCancelError('上传已取消'));
            return;
          }
          updateTransferJob(jobId, { status: 'fail', cancelable: false, aborter: null });
          scheduleTransferJobRemoval(jobId, 6000);
          reject(new Error('上传中断'));
        };

        xhr.onload = () => {
          const data = (() => {
            try {
              return JSON.parse(xhr.responseText || '{}');
            } catch (_) {
              return {};
            }
          })();

          if (xhr.status >= 200 && xhr.status < 300) {
            const currentJob = getTransferJob(jobId);
            const smoothSpeed = currentJob ? Number(currentJob.speedBps) || 0 : 0;
            updateTransferJob(jobId, {
              loaded: totalBytes,
              percent: 100,
              speedBps: Math.max(smoothSpeed, averageSpeedBps(currentJob ? currentJob.startedAt : Date.now(), totalBytes)),
              status: 'done',
              cancelable: false,
              aborter: null,
              lastTickAt: Date.now(),
            });
            scheduleTransferJobRemoval(jobId, 3500);
            resolve(data);
            return;
          }

          const message = data.error || `上传失败(${xhr.status})`;
          updateTransferJob(jobId, { status: 'fail', cancelable: false, aborter: null });
          scheduleTransferJobRemoval(jobId, 7000);
          reject(new Error(message));
        };

        xhr.send(form);
      });
    }


    function fmtLeftSeconds(left) {
      if (left <= 0) return '已过期';
      const mm = Math.floor(left / 60);
      const ss = left % 60;
      return `${mm}:${String(ss).padStart(2, '0')}`;
    }

    function tickQrCountdown() {
      if (state.role !== 'desktop') return;
      if (!ui.qrExpire) return;
      const now = Math.floor(Date.now() / 1000);
      const left = Math.max(0, state.qrExpiresAt - now);
      ui.qrExpire.textContent = `有效期剩余 ${fmtLeftSeconds(left)}`;
      if (left === 0 && !state.qrRefreshInFlight) {
        refreshQrPayload();
      }
    }

    function startQrCountdown() {
      if (state.qrCountdownTimer) clearInterval(state.qrCountdownTimer);
      tickQrCountdown();
      state.qrCountdownTimer = setInterval(tickQrCountdown, 1000);
    }

    function applyQrPayload(payload) {
      if (!payload || !payload.mobile_url || !payload.mobile_qr_data_url) return;
      serverConfig.mobileUrl = payload.mobile_url;
      serverConfig.mobileQrDataUrl = payload.mobile_qr_data_url;
      state.qrExpiresAt = Number(payload.token_expires_at || 0);
      ui.qrCard.classList.add('show');
      ui.qrImage.src = serverConfig.mobileQrDataUrl;
      ui.qrLink.href = serverConfig.mobileUrl;
      ui.qrLink.textContent = serverConfig.mobileUrl;
      tickQrCountdown();
    }

    async function refreshQrPayload() {
      if (state.role !== 'desktop' || state.qrRefreshInFlight) return;
      state.qrRefreshInFlight = true;
      if (ui.refreshQrBtn) ui.refreshQrBtn.disabled = true;
      try {
        const resp = await fetch('/auth/mobile-token');
        if (!resp.ok) throw new Error(`refresh failed: ${resp.status}`);
        const payload = await resp.json();
        applyQrPayload(payload);
      } catch (err) {
        console.error(err);
      } finally {
        state.qrRefreshInFlight = false;
        if (ui.refreshQrBtn) ui.refreshQrBtn.disabled = false;
      }
    }

    async function uploadFiles(files, source = state.role) {
      for (const file of files) {
        if (file.size > state.maxUploadBytes) {
          showToast(`${file.name} 超过上传上限`);
          continue;
        }

        try {
          await sendFileWithProgress(file, source);
          showToast(`${file.name} 上传成功`);
        } catch (err) {
          if (isCancelError(err)) {
            showToast(`${file.name} 已取消`);
            continue;
          }
          showToast(`${file.name} 上传失败`);
          console.error(err);
        }
      }
    }

    function wsUrl() {
      const p = location.protocol === 'https:' ? 'wss' : 'ws';
      const url = new URL(`${p}://${location.host}/ws`);
      if (state.sessionId) url.searchParams.set('session_id', state.sessionId);
      return url.toString();
    }

    function resetHeartbeat() {
      if (state.hbTimer) clearInterval(state.hbTimer);
      const interval = document.hidden ? 7000 : 20000;
      state.hbTimer = setInterval(() => {
        if (state.ws && state.ws.readyState === WebSocket.OPEN) {
          state.ws.send(JSON.stringify({ type: 'ping', ts: Date.now(), hidden: document.hidden }));
        }
      }, interval);
    }

    function connectWS() {
      setStatus('连接中...');
      state.ws = new WebSocket(wsUrl());

      state.ws.onopen = () => {
        setStatus('已连接', true, false);
        resetHeartbeat();
      };

      state.ws.onmessage = (event) => {
        let data;
        try {
          data = JSON.parse(event.data);
        } catch (_) {
          return;
        }

        if (data.type === 'init' && Array.isArray(data.records)) {
          state.records = [];
          state.recordIdSet.clear();
          for (const record of data.records) {
            addRecord(record, false);
          }
          renderRecords();
          return;
        }

        if (data.type === 'new_record' && data.record) {
          addRecord(data.record, true);
          return;
        }

        if (data.type === 'remove_record' && data.id) {
          removeRecord(data.id);
        }
      };

      state.ws.onclose = () => {
        setStatus('连接断开，重连中...', false, true);
        if (state.hbTimer) clearInterval(state.hbTimer);
        state.reconnectTimer = setTimeout(connectWS, 1800);
      };

      state.ws.onerror = () => {
        setStatus('连接异常', false, true);
      };
    }

    async function notifyInBackground(record) {
      if (!('Notification' in window)) return;
      if (!document.hidden) return;

      if (Notification.permission === 'default') {
        try { await Notification.requestPermission(); } catch (_) {}
      }
      if (Notification.permission === 'granted') {
        new Notification('收到新文件', { body: record.name });
      }
    }

    async function initHistory() {
      try {
        const resp = await fetch('/records', { headers: authHeaders() });
        if (!resp.ok) return;
        const data = await resp.json();
        if (!Array.isArray(data.records)) return;
        state.records = [];
        state.recordIdSet.clear();
        for (const record of data.records) {
          addRecord(record, false);
        }
        renderRecords();
      } catch (_) {
      }
    }

    function syncLimitInput() {
      const gb = Math.max(1, Math.round(state.maxUploadBytes / 1024 / 1024 / 1024));
      ui.uploadLimitGb.value = String(gb);
    }

    async function loadSettings() {
      try {
        const resp = await fetch('/settings', { headers: authHeaders() });
        if (!resp.ok) return;
        const data = await resp.json();
        if (typeof data.max_upload_bytes === 'number' && data.max_upload_bytes > 0) {
          state.maxUploadBytes = data.max_upload_bytes;
          syncLimitInput();
        }
        if (typeof data.download_dir === 'string' && data.download_dir.trim()) {
          state.downloadDir = data.download_dir.trim();
          ui.downloadDirInput.value = state.downloadDir;
        }
        if (typeof data.default_download_dir === 'string' && data.default_download_dir.trim()) {
          state.defaultDownloadDir = data.default_download_dir.trim();
        }
      } catch (_) {
      }
    }

    async function saveDownloadDir() {
      const downloadDir = (ui.downloadDirInput.value || '').trim();
      if (!downloadDir) {
        showToast('请输入下载目录');
        return;
      }

      try {
        const resp = await fetch('/settings/download-dir', {
          method: 'POST',
          headers: {
            ...authHeaders(),
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ download_dir: downloadDir }),
        });
        const data = await resp.json().catch(() => ({}));
        if (!resp.ok) throw new Error(data.error || `保存失败(${resp.status})`);
        state.downloadDir = data.download_dir;
        ui.downloadDirInput.value = state.downloadDir;
        showToast('下载目录已更新');
      } catch (err) {
        console.error(err);
        showToast('下载目录更新失败');
      }
    }

    async function openDownloadDir() {
      try {
        const resp = await fetch('/settings/open-download-dir', {
          method: 'POST',
          headers: authHeaders(),
        });
        const data = await resp.json().catch(() => ({}));
        if (!resp.ok) throw new Error(data.error || `打开失败(${resp.status})`);
      } catch (err) {
        console.error(err);
        showToast('打开目录失败');
      }
    }

    function hasDesktopDirectoryPicker() {
      return !!(window.pywebview && window.pywebview.api && typeof window.pywebview.api.choose_download_directory === 'function');
    }

    function syncDirectoryPickerAvailability() {
      if (!ui.pickDownloadDirBtn) return;
      const ready = hasDesktopDirectoryPicker();
      ui.pickDownloadDirBtn.disabled = false;
      ui.pickDownloadDirBtn.title = ready ? '' : '当前运行模式不支持系统文件夹选择';
    }

    function probeDirectoryPickerAvailability(maxAttempts = 20, intervalMs = 300) {
      if (hasDesktopDirectoryPicker()) {
        syncDirectoryPickerAvailability();
        return;
      }
      let attempts = 0;
      const timer = setInterval(() => {
        attempts += 1;
        syncDirectoryPickerAvailability();
        if (hasDesktopDirectoryPicker() || attempts >= maxAttempts) {
          clearInterval(timer);
        }
      }, intervalMs);
    }

    async function pickDownloadDir() {
      if (!hasDesktopDirectoryPicker()) {
        showToast('当前运行模式不支持系统文件夹选择');
        return;
      }

      const current = (ui.downloadDirInput.value || state.downloadDir || state.defaultDownloadDir || '').trim();
      try {
        const selected = await window.pywebview.api.choose_download_directory(current);
        if (!selected) {
          showToast('未选择目录');
          return;
        }
        ui.downloadDirInput.value = selected;
        await saveDownloadDir();
      } catch (err) {
        console.error(err);
        showToast('选择目录失败');
      }
    }

    async function saveUploadLimit() {
      const gb = Number(ui.uploadLimitGb.value || '10');
      if (!Number.isFinite(gb) || gb < 1 || gb > 100) {
        showToast('上传限制需在 1 到 100 GB');
        return;
      }
      const maxUploadBytes = Math.floor(gb * 1024 * 1024 * 1024);
      try {
        const resp = await fetch('/settings/upload-limit', {
          method: 'POST',
          headers: {
            ...authHeaders(),
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ max_upload_bytes: maxUploadBytes }),
        });
        const data = await resp.json().catch(() => ({}));
        if (!resp.ok) throw new Error(data.error || `保存失败(${resp.status})`);
        state.maxUploadBytes = data.max_upload_bytes;
        syncLimitInput();
        showToast('上传限制已更新');
      } catch (err) {
        console.error(err);
        showToast('上传限制更新失败');
      }
    }

    function bindEvents() {
      const onPywebviewReady = () => {
        syncDirectoryPickerAvailability();
      };
      window.addEventListener('pywebviewready', onPywebviewReady);
      document.addEventListener('pywebviewready', onPywebviewReady);
      ui.settingsBtn.addEventListener('click', () => toggleSettingsPanel());
      ui.sendBtn.addEventListener('click', () => ui.fileInput.click());
      ui.fileInput.addEventListener('change', (e) => {
        const files = Array.from(e.target.files || []);
        if (files.length) uploadFiles(files, state.role);
        e.target.value = '';
      });
      document.addEventListener('visibilitychange', async () => {
        resetHeartbeat();
        if (document.hidden && 'Notification' in window && Notification.permission === 'default') {
          try { await Notification.requestPermission(); } catch (_) {}
        }
      });

      if (state.role === 'desktop') {
        ui.limitRow.style.display = 'flex';
        ui.downloadDirRow.style.display = 'flex';
        ui.saveLimitBtn.addEventListener('click', () => saveUploadLimit());
        ui.pickDownloadDirBtn.addEventListener('click', () => pickDownloadDir());
        ui.saveDownloadDirBtn.addEventListener('click', () => saveDownloadDir());
        ui.openDownloadDirBtn.addEventListener('click', () => openDownloadDir());
        ui.resetDownloadDirBtn.addEventListener('click', () => {
          if (!state.defaultDownloadDir) {
            showToast('默认下载目录不可用');
            return;
          }
          ui.downloadDirInput.value = state.defaultDownloadDir;
          saveDownloadDir();
        });
        syncDirectoryPickerAvailability();
        probeDirectoryPickerAvailability();

        if (serverConfig.mobileQrDataUrl && serverConfig.mobileUrl) {
          applyQrPayload({
            mobile_url: serverConfig.mobileUrl,
            mobile_qr_data_url: serverConfig.mobileQrDataUrl,
            token_expires_at: serverConfig.tokenExpiresAt,
          });
          startQrCountdown();
        }

        if (ui.refreshQrBtn) {
          ui.refreshQrBtn.addEventListener('click', () => refreshQrPayload());
        }

        ui.dropZone.style.display = 'block';
        ui.tip.textContent = '可点击“发送文件”，也可直接拖拽；下载按钮会直接保存到设置中的下载目录。';

        const enter = () => ui.dropZone.classList.add('active');
        const leave = () => ui.dropZone.classList.remove('active');

        document.addEventListener('dragenter', (e) => { e.preventDefault(); enter(); });
        document.addEventListener('dragover', (e) => { e.preventDefault(); enter(); });
        document.addEventListener('dragleave', (e) => {
          e.preventDefault();
          if (e.relatedTarget === null) leave();
        });

        document.addEventListener('drop', (e) => {
          e.preventDefault();
          leave();
          const files = Array.from(e.dataTransfer?.files || []);
          if (files.length) uploadFiles(files, 'desktop');
        });
      } else {
        ui.limitRow.style.display = 'none';
        ui.downloadDirRow.style.display = 'none';
        ui.tip.textContent = '点击“发送文件”上传到电脑。';
      }
    }

    async function init() {
      ui.meta.textContent = `${location.origin} · 当前设备: ${state.role === 'desktop' ? '电脑端' : '手机端'}`;
      syncLimitInput();
      if (serverConfig.accessDenied) {
        setStatus('未授权访问', false, true);
        ui.tip.textContent = serverConfig.accessDeniedReason || '当前访问未授权，请重新扫码。';
        ui.sendBtn.disabled = true;
        ui.sendBtn.style.opacity = '0.5';
        ui.settingsPanel.style.opacity = '0.55';
        ui.settingsPanel.style.pointerEvents = 'none';
        toggleSettingsPanel(false);
        return;
      }
      await loadSettings();
      bindEvents();
      toggleSettingsPanel(false);
      initHistory();
      connectWS();
    }

    init();
    window.__lftOpenSettings = () => toggleSettingsPanel(true);
  </script>
</body>
</html>
